#include "web_server.h"

// import web page
// C requires const keyword when used in static storage duration vars
// so len var defined by in *.hex files can not be used in files array
// it is defined as unsigned int (missing const)
// Arrays generated by xxd are not NULL terminated!!
ICACHE_FLASH_ATTR
#include "embed_web/index.html.hex"

ICACHE_FLASH_ATTR
#include "embed_web/style.css.hex"

ICACHE_FLASH_ATTR
#include "embed_web/app.min.js.hex"

typedef struct {
  const char *path;
  const unsigned char *content;
  const unsigned int len;
} web_file_t;

web_file_t files[] = {
    {"GET / ", web_index_html, sizeof(web_index_html)},
    {"GET /app.js", web_app_min_js, sizeof(web_app_min_js)},
    {"GET /style.css", web_style_css, sizeof(web_style_css)},
};
enum { HTML, JS, CSS };

// headers
typedef struct {
  const char *hdr;
} hdrs_t;

hdrs_t hdrs[] = {
    {"HTTP/1.1 200 OK\r\nConnection: Close\r\n"},       //
    {"HTTP/1.1 404 Not Found\r\nConnection: Close\r\n"} //
};

enum { OK_200, ERROR_404 };

xSemaphoreHandle wifi_ready = NULL;

static bool reason_error_auth(uint8_t reason) {
  return (reason == REASON_AUTH_FAIL ||
          reason == REASON_4WAY_HANDSHAKE_TIMEOUT ||
          reason == REASON_ASSOC_FAIL || reason == REASON_AUTH_EXPIRE);
}

static bool reason_error_ap(uint8_t reason) {
  return (reason == REASON_NO_AP_FOUND || reason == REASON_BEACON_TIMEOUT ||
          reason == REASON_ASSOC_TOOMANY || reason == REASON_HANDSHAKE_TIMEOUT);
}

void wifi_event(System_Event_t *event) {
  struct ip_info info;
  uint8_t reason = event->event_info.disconnected.reason;
  wifi_get_ip_info(STATION_IF, &info);

  switch (event->event_id) {
  case EVENT_STAMODE_GOT_IP:
    xSemaphoreGive(wifi_ready);
    break;
  case EVENT_STAMODE_DISCONNECTED:
    if (reason_error_auth(reason)) {
      os_printf("authentication failed\n");
      wifi_station_disconnect();
      xSemaphoreTake(wifi_ready, portMAX_DELAY);
      break;
    }
    if (reason_error_ap(reason)) {
      os_printf("AP not found\n");
      wifi_station_disconnect();
      xSemaphoreTake(wifi_ready, portMAX_DELAY);
      break;
    }
    os_printf("reason %d\n", reason);
    os_printf("check esp_wifi.h; REASON_* enum\n");
    break;
  default:
    break;
  }
}

void wifi_init(void) {
  WIFI_MODE mode = STATION_MODE;
  struct station_config cfg = {
      .ssid = SSID, .password = PASSWD, .bssid_set = 0, .bssid = "0"};

  wifi_set_event_handler_cb(wifi_event);

  if (wifi_set_opmode(mode)) {
    DEB("Set STATION mode\n");
  } else {
    DEB("Failed to set STATION mode\n");
    system_restart();
  };

  if (wifi_station_set_config(&cfg)) {
    DEB("Set cfg: SSID=%s; PASSWD=(see include/secret.h)\n", SSID);
  } else {
    DEB("Failed to set cfg\n");
    system_restart();
  };

  if (wifi_station_dhcpc_status() != DHCP_STARTED) {
    if (!wifi_station_dhcpc_start()) {
      DEB("Failed to start DHCP\n");
      system_restart();
    }
  } else {
    DEB("Started DHCP\n");
  }
  wifi_station_connect();
  xSemaphoreTake(wifi_ready, portMAX_DELAY);
  // will be released by EVENT_STAMODE_GOT_IP
}

int send_file(int sock, const unsigned char *buf, int len) {
  int sent = 0;
  while (sent < len) {
    int r = lwip_send(sock, buf + sent, len - sent, 0);
    if (r <= 0)
      return r;
    sent += r;
  }
  return sent;
}

int send_queue(int sock) {
  nmea_msg_t msg;
  unsigned long msg_no = uxQueueMessagesWaiting(nmea_queue);
  for (int i = 0; i < msg_no; i++) {
    if (xQueueReceive(nmea_queue, &msg, portMAX_DELAY) == pdTRUE) {
      uint8_t len = strnlen(msg.line, NMEA_MAX_LEN);
      lwip_send(sock, msg.line, len, 0);
      lwip_send(sock, "\r\n", 2, 0);
    }
  }
}

void handle_client(int client) {
  char rx[RECV_BUF_LEN];
  int rx_len = lwip_recv(client, rx, sizeof(rx), 0);
  if (rx_len <= 0) {
    lwip_close(client);
    return;
  }
  rx[rx_len] = '\0';
  // send HTML page
  if (strncmp(rx, "GET / ", 6) == 0) {
    send_hdr(client, OK_200, files[HTML].len);
    send_file(client, files[HTML].content, files[HTML].len);
  }
  // send java script
  else if (strncmp(rx, "GET /app.js", 11) == 0) {
    send_hdr(client, OK_200, files[JS].len);
    send_file(client, files[JS].content, files[JS].len);
  }
  // send styles CSS
  else if (strncmp(rx, "GET /style.css", 14) == 0) {
    send_hdr(client, OK_200, files[CSS].len);
    send_file(client, files[CSS].content, files[CSS].len);
  }
  // send NMEA data
  else if (strncmp(rx, "GET /nmea", 9) == 0) {
    send_hdr(client, OK_200, 0);
    send_queue(client);
  }
  // 404 error
  else {
    send_hdr(client, ERROR_404, 0);
  }

  lwip_shutdown(client, SHUT_WR);
  lwip_close(client);
}

void send_hdr(int client, int hdr_type, int cont_len) {
  char hdr[HDR_LEN];
  int hdr_len;
  if (cont_len > 0) {
    hdr_len = snprintf(hdr, HDR_LEN,
                       "%s"
                       "Content-Length: %d\r\n"
                       "\r\n",
                       hdrs[hdr_type].hdr, //
                       cont_len);
  } else {
    hdr_len = snprintf(hdr, HDR_LEN,
                       "%s"
                       "\r\n",
                       hdrs[hdr_type].hdr);
  }
  send_file(client, (unsigned char *)hdr, hdr_len);
}
